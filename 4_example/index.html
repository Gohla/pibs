<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Example: Interactive Parser Development - Build your own Programmatic Incremental Build System</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././diff2html.min.css">
        <link rel="stylesheet" href=".././mdbook-admonish.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../0_intro/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../0_intro/1_setup/index.html"><strong aria-hidden="true">1.1.</strong> Setup</a></li></ol></li><li class="chapter-item expanded "><a href="../1_programmability/index.html"><strong aria-hidden="true">2.</strong> Programmability</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../1_programmability/1_api/index.html"><strong aria-hidden="true">2.1.</strong> Programmable Build System API</a></li><li class="chapter-item expanded "><a href="../1_programmability/2_non_incremental/index.html"><strong aria-hidden="true">2.2.</strong> Non-Incremental Context</a></li></ol></li><li class="chapter-item expanded "><a href="../2_incrementality/index.html"><strong aria-hidden="true">3.</strong> Incrementality</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../2_incrementality/1_require_file/index.html"><strong aria-hidden="true">3.1.</strong> Requiring Files</a></li><li class="chapter-item expanded "><a href="../2_incrementality/2_stamp/index.html"><strong aria-hidden="true">3.2.</strong> Stamps</a></li><li class="chapter-item expanded "><a href="../2_incrementality/3_dependency/index.html"><strong aria-hidden="true">3.3.</strong> Dynamic Dependencies</a></li><li class="chapter-item expanded "><a href="../2_incrementality/4_store/index.html"><strong aria-hidden="true">3.4.</strong> Dependency Graph Store</a></li><li class="chapter-item expanded "><a href="../2_incrementality/5_context/index.html"><strong aria-hidden="true">3.5.</strong> Incremental Top-Down Context</a></li><li class="chapter-item expanded "><a href="../2_incrementality/6_example/index.html"><strong aria-hidden="true">3.6.</strong> Incrementality Example</a></li></ol></li><li class="chapter-item expanded "><a href="../3_min_sound/index.html"><strong aria-hidden="true">4.</strong> Testing Incrementality & Soundness</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../3_min_sound/1_session/index.html"><strong aria-hidden="true">4.1.</strong> Minimality with Sessions</a></li><li class="chapter-item expanded "><a href="../3_min_sound/2_tracker/index.html"><strong aria-hidden="true">4.2.</strong> Tracking Build Events</a></li><li class="chapter-item expanded "><a href="../3_min_sound/3_test/index.html"><strong aria-hidden="true">4.3.</strong> Integration Testing</a></li><li class="chapter-item expanded "><a href="../3_min_sound/4_fix_task_dep/index.html"><strong aria-hidden="true">4.4.</strong> Fix Superfluous Task Dependency</a></li><li class="chapter-item expanded "><a href="../3_min_sound/5_overlap/index.html"><strong aria-hidden="true">4.5.</strong> Prevent Overlapping File Writes</a></li><li class="chapter-item expanded "><a href="../3_min_sound/6_hidden_dep/index.html"><strong aria-hidden="true">4.6.</strong> Prevent Hidden Dependencies</a></li><li class="chapter-item expanded "><a href="../3_min_sound/7_cycle/index.html"><strong aria-hidden="true">4.7.</strong> Prevent Cycles</a></li></ol></li><li class="chapter-item expanded "><a href="../4_example/index.html" class="active"><strong aria-hidden="true">5.</strong> Example: Interactive Parser Development</a></li><li class="chapter-item expanded affix "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="../a_appendix/1_pie.html"><strong aria-hidden="true">6.</strong> PIE Implementations & Publications</a></li><li class="chapter-item expanded "><a href="../a_appendix/2_related_work.html"><strong aria-hidden="true">7.</strong> Related Work</a></li><li class="chapter-item expanded "><a href="../a_appendix/3_future_work.html"><strong aria-hidden="true">8.</strong> Future Work</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
<!-- CHANGE: removed all but light and ayu theme, and renamed ayu to dark -->                          
<!--                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>-->
<!--                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>-->
<!--                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>-->
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Dark</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Build your own Programmatic Incremental Build System</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Gohla/pie/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Gohla/pie/edit/master/tutorial/src/4_example/index.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="example-interactive-parser-development"><a class="header" href="#example-interactive-parser-development">Example: Interactive Parser Development</a></h1>
<p>To demonstrate what can be done with the programmatic incremental build system we just created, we will create a simple “interactive parser development” example.
In this example, we can interactively develop a grammar for a new (programming) language, and test that grammar against several example files written in the new language.</p>
<p>We will use <a href="https://pest.rs/" title="" target="_blank">pest</a> as the parser framework, because it is written in Rust and can be easily embedded into an application.
Pest uses Parsing Expression Grammars (PEGs) which are easy to understand, which is also good for this example.</p>
<p>For the GUI, we will use <a href="https://ratatui.rs/" title="" target="_blank">Ratatui</a>, which is a cross-platform terminal GUI framework, along with <a href="https://github.com/rhysd/tui-textarea" title="" target="_blank">tui-textarea</a> for a text editor widget.
We could use a more featured GUI framework like <a href="https://github.com/emilk/egui" title="" target="_blank">egui</a>, but for this example we’ll keep it simple and runnable in a terminal.</p>
<p>We will continue as follows:</p>
<ol>
<li>Implement compilation of pest grammars and parsing of text with the compiled grammar.</li>
<li>Create tasks for grammar compilation and parsing.</li>
<li>Parse CLI arguments and run these tasks in a non-interactive setting.</li>
<li>Create a terminal GUI for interactive parser development.</li>
</ol>
<h2 id="compiling-grammars-and-parsing"><a class="header" href="#compiling-grammars-and-parsing">Compiling grammars and parsing</a></h2>
<p>First we will implement compilation of pest grammars, and parsing text with a compiled grammar.
A <a href="https://pest.rs/book/grammars/peg.html" title="" target="_blank">pest grammar</a> contains named rules that describe how to parse something.
For example, <code>number = { ASCII_DIGIT+ }</code> means that a <code>number</code> is parsed by parsing 1 or more <code>ASCII_DIGIT</code>, with <code>ASCII_DIGIT</code> being a builtin rule that parses ASCII numbers 0-9.</p>
<p>Add the following dev-dependencies to <code>pie/Cargo.toml</code>:</p>
<div class="diff2html" id="diff2html_0"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/Cargo.toml
+++ pie/Cargo.toml
@@ -9,3 +9,6 @@
 [dev-dependencies]
 dev_shared = { path = "../dev_shared" }
 assert_matches = "1"
+pest = "2"
+pest_meta = "2"
+pest_vm = "2"
`;
    let target = document.getElementById('diff2html_0');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<ul>
<li><a href="https://crates.io/crates/pest" title="" target="_blank">pest</a> is the library for parsing with pest grammars.</li>
<li><a href="https://crates.io/crates/pest_meta" title="" target="_blank">pest_meta</a> validates, optimises, and compiles pest grammars.</li>
<li><a href="https://crates.io/crates/pest_vm" title="" target="_blank">pest_vm</a> provides parsing with a compiled pest grammar, without having to generate Rust code for grammars, enabling interactive use.</li>
</ul>
<p>Create the <code>pie/examples/parser_dev/main.rs</code> file and add an empty main function to it:</p>
<pre><code class="language-rust ">fn main() {

}</code></pre>
<p>Confirm the example can be run with <code>cargo run --example parser_dev</code>.</p>
<p>Let’s implement the pest grammar compiler and parser.
Add <code>parse</code> as a public module to <code>pie/examples/parser_dev/main.rs</code>:</p>
<div class="diff2html" id="diff2html_1"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/examples/parser_dev/main.rs
+++ pie/examples/parser_dev/main.rs
@@ -1,3 +1,5 @@
+pub mod parse;
+
 fn main() {
 
 }
`;
    let target = document.getElementById('diff2html_1');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We will add larger chunks of code from now on, compared to the rest of the tutorial, to keep things going.
Create the <code>pie/examples/parser_dev/parse.rs</code> file and add to it:</p>
<pre><code class="language-rust ">use std::collections::HashSet;
use std::fmt::Write;

/// Parse programs with a compiled pest grammar.
#[derive(Clone, Eq, PartialEq, Debug)]
pub struct CompiledGrammar {
  rules: Vec&lt;pest_meta::optimizer::OptimizedRule&gt;,
  rule_names: HashSet&lt;String&gt;,
}

impl CompiledGrammar {
  /// Compile the pest grammar from `grammar_text`, using `path` to annotate errors. Returns a [`Self`] instance.
  ///
  /// # Errors
  ///
  /// Returns `Err(error_string)` when compiling the grammar fails.
  pub fn new(grammar_text: &amp;str, path: Option&lt;&amp;str&gt;) -&gt; Result&lt;Self, String&gt; {
    match pest_meta::parse_and_optimize(grammar_text) {
      Ok((builtin_rules, rules)) =&gt; {
        let mut rule_names = HashSet::with_capacity(builtin_rules.len() + rules.len());
        rule_names.extend(builtin_rules.iter().map(|s| s.to_string()));
        rule_names.extend(rules.iter().map(|s| s.name.clone()));
        Ok(Self { rules, rule_names })
      },
      Err(errors) =&gt; {
        let mut error_string = String::new();
        for mut error in errors {
          if let Some(path) = path.as_ref() {
            error = error.with_path(path);
          }
          error = error.renamed_rules(pest_meta::parser::rename_meta_rule);
          let _ = writeln!(error_string, &quot;{}&quot;, error); // Ignore error: writing to String cannot fail.
        }
        Err(error_string)
      }
    }
  }
}</code></pre>
<p>The <code>CompiledGrammar</code> struct contains a parsed pest grammar, consisting of a <code>Vec</code> of optimised parsing rules, and a hash set of rule names.
We will use this struct as an output of a task in the future, so we derive <code>Clone</code>, <code>Eq</code>, and <code>Debug</code>.</p>
<p>The <code>new</code> function takes text of a pest grammar, and an optional file path for error reporting, and creates a <code>CompilerGrammar</code> or an error in the form of a <code>String</code>.
We’re using <code>String</code>s as errors in this example for simplicity.</p>
<p>We compile the grammar with <code>pest_meta::parse_and_optimize</code>.
If successful, we gather the rule names into a hash set and return a <code>CompiledGrammar</code>.
If not, multiple errors are returned, which are first preprocessed with <code>with_path</code> and <code>renamed_rules</code>, and then written to a single String with <code>writeln!</code>, which is returned as the error.</p>
<p>Now we implement parsing using a <code>CompiledGrammar</code>.
Add the <code>parse</code> method to <code>pie/examples/parser_dev/parse.rs</code>:</p>
<div class="diff2html" id="diff2html_2"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/examples/parser_dev/parse.rs
+++ pie/examples/parser_dev/parse.rs
@@ -35,4 +35,30 @@
       }
     }
   }
+
+  /// Parse ${"`"}program_text${"`"} with rule ${"`"}rule_name${"`"} using this compiled grammar, using ${"`"}path${"`"} to annotate errors. Returns
+  /// parsed pairs formatted as a string.
+  ///
+  /// # Errors
+  ///
+  /// Returns ${"`"}Err(error_string)${"`"} when parsing fails.
+  pub fn parse(&self, program_text: &str, rule_name: &str, path: Option<&str>) -> Result<String, String> {
+    if !self.rule_names.contains(rule_name) {
+      let message = format!("rule '{}' was not found", rule_name);
+      return Err(message);
+    }
+    // Note: can't store ${"`"}Vm${"`"} in ${"`"}CompiledGrammar${"`"} because ${"`"}Vm${"`"} is not ${"`"}Clone${"`"} nor ${"`"}Eq${"`"}.
+    let vm = pest_vm::Vm::new(self.rules.clone());
+    match vm.parse(rule_name, program_text) {
+      Ok(pairs) => Ok(format!("{}", pairs)),
+      Err(mut error) => {
+        if let Some(path) = path {
+          error = error.with_path(path);
+        }
+        error = error.renamed_rules(|r| r.to_string());
+        let error_string = format!("{}", error);
+        Err(error_string)
+      }
+    }
+  }
 }
`;
    let target = document.getElementById('diff2html_2');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p><code>parse</code> takes the text of the program to parse, the rule name to start parsing with, and an optional file path for error reporting.</p>
<p>We first check whether <code>rule_name</code> exists by looking for it in <code>self.rule_names</code>, and return an error if it does not exist.
We have to do this because <code>pest_vm</code> panics when the rule name does not exist, which would kill the entire program.</p>
<p>If the rule name is valid, we create a <code>pest_vm::Vm</code> and <code>parse</code>.
If successful, we get a <code>pairs</code> iterator that describes how the program was parsed, which are typically used to <a href="https://pest.rs/book/examples/json.html#ast-generation" title="" target="_blank">create an Abstract Syntax Tree (AST) in Rust code</a>.
However, for simplicity we just format the pairs as a <code>String</code> and return that.
If not successful, we do the same as the previous function, but instead for 1 error instead of multiple.</p>
<p>Unfortunately we cannot store <code>pest_vm::Vm</code> in <code>CompiledGrammar</code>, because <code>Vm</code> does not implement <code>Clone</code> nor <code>Eq</code>.
Therefore, we have to create a new <code>Vm</code> every time we parse, which has a small performance overhead, but that is fine for this example.</p>
<p>To check whether this code does what we want, we’ll write a test for it (yes, you can add tests to examples in Rust!).
Add to <code>pie/examples/parser_dev/parse.rs</code>:</p>
<pre><code class="language-rust ">#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_compile_parse() -&gt; Result&lt;(), String&gt; {
    // Grammar compilation failure.
    let result = CompiledGrammar::new(&quot;asd = { fgh } qwe = { rty }&quot;, None);
    assert!(result.is_err());
    println!(&quot;{}&quot;, result.unwrap_err());

    // Grammar that parses numbers.
    let compiled_grammar = CompiledGrammar::new(&quot;num = { ASCII_DIGIT+ }&quot;, None)?;
    println!(&quot;{:?}&quot;, compiled_grammar);

    // Parse failure
    let result = compiled_grammar.parse(&quot;a&quot;, &quot;num&quot;, None);
    assert!(result.is_err());
    println!(&quot;{}&quot;, result.unwrap_err());
    // Parse failure due to non-existent rule.
    let result = compiled_grammar.parse(&quot;1&quot;, &quot;asd&quot;, None);
    assert!(result.is_err());
    println!(&quot;{}&quot;, result.unwrap_err());
    // Parse success
    let result = compiled_grammar.parse(&quot;1&quot;, &quot;num&quot;, None);
    assert!(result.is_ok());
    println!(&quot;{}&quot;, result.unwrap());

    Ok(())
  }
}</code></pre>
<p>We test grammar compilation failure and success, and parse failure and success.
Run this test with <code>cargo test --example parser_dev -- --show-output</code>, which also shows what the returned <code>String</code>s look like.</p>
<h2 id="tasks"><a class="header" href="#tasks">Tasks</a></h2>
<p>Now we’ll implement tasks for compiling a grammar and parsing.
Add <code>task</code> as a public module to <code>pie/examples/parser_dev/main.rs</code>:</p>
<div class="diff2html" id="diff2html_3"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/examples/parser_dev/main.rs
+++ pie/examples/parser_dev/main.rs
@@ -1,4 +1,5 @@
 pub mod parse;
+pub mod task;
 
 fn main() {
 
`;
    let target = document.getElementById('diff2html_3');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Create the <code>pie/examples/parser_dev/task.rs</code> file and add to it:</p>
<pre><code class="language-rust ">use std::io::Read;
use std::path::{Path, PathBuf};

use pie::{Context, Task};

use crate::parse::CompiledGrammar;

/// Tasks for compiling a grammar and parsing files with it.
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub enum Tasks {
  CompileGrammar { grammar_file_path: PathBuf },
  Parse { compiled_grammar_task: Box&lt;Tasks&gt;, program_file_path: PathBuf, rule_name: String }
}

impl Tasks {
  /// Create a [`Self::CompileGrammar`] task that compiles the grammar in file `grammar_file_path`.
  pub fn compile_grammar(grammar_file_path: impl Into&lt;PathBuf&gt;) -&gt; Self {
    Self::CompileGrammar { grammar_file_path: grammar_file_path.into() }
  }

  /// Create a [`Self::Parse`] task that uses the compiled grammar returned by requiring `compiled_grammar_task` to
  /// parse the program in file `program_file_path`, starting parsing with `rule_name`.
  pub fn parse(
    compiled_grammar_task: &amp;Tasks,
    program_file_path: impl Into&lt;PathBuf&gt;,
    rule_name: impl Into&lt;String&gt;
  ) -&gt; Self {
    Self::Parse {
      compiled_grammar_task: Box::new(compiled_grammar_task.clone()),
      program_file_path: program_file_path.into(),
      rule_name: rule_name.into()
    }
  }
}

/// Outputs for [`Tasks`].
#[derive(Clone, Eq, PartialEq, Debug)]
pub enum Outputs {
  CompiledGrammar(CompiledGrammar),
  Parsed(Option&lt;String&gt;)
}</code></pre>
<p>We create a <code>Tasks</code> enum with:</p>
<ul>
<li>A <code>CompileGrammar</code> variant for compiling a grammar from a file.</li>
<li>A <code>Parse</code> variant that uses the compiled grammar returned from another task to parse a program in a file, starting parsing with a specific rule given by name.</li>
</ul>
<p><code>compile_grammar</code> and <code>parse</code> are convenience functions for creating these variants.
We derive <code>Clone</code>, <code>Eq</code>, <code>Hash</code> and <code>Debug</code> as these are required for tasks.</p>
<p>We create an <code>Outputs</code> enum for storing the results of these tasks, and derive the required traits.</p>
<p>Since both tasks will require a file, and we’re using <code>String</code>s as errors, we will implement a convenience function for this.
Add to <code>pie/examples/parser_dev/task.rs</code>:</p>
<pre><code class="language-rust ">fn require_file_to_string&lt;C: Context&lt;Tasks&gt;&gt;(context: &amp;mut C, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;String, String&gt; {
  let path = path.as_ref();
  let mut file = context.require_file(path)
    .map_err(|e| format!(&quot;Opening file '{}' for reading failed: {}&quot;, path.display(), e))?
    .ok_or_else(|| format!(&quot;File '{}' does not exist&quot;, path.display()))?;
  let mut text = String::new();
  file.read_to_string(&amp;mut text)
    .map_err(|e| format!(&quot;Reading file '{}' failed: {}&quot;, path.display(), e))?;
  Ok(text)
}</code></pre>
<p><code>require_file_to_string</code> is like <code>context.require_file</code>, but converts all errors to <code>String</code>.</p>
<p>Now we implement <code>Task</code> for <code>Tasks</code>.
Add to <code>pie/examples/parser_dev/task.rs</code>:</p>
<pre><code class="language-rust ">impl Task for Tasks {
  type Output = Result&lt;Outputs, String&gt;;

  fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output {
    match self {
      Tasks::CompileGrammar { grammar_file_path } =&gt; {
        let grammar_text = require_file_to_string(context, grammar_file_path)?;
        let compiled_grammar = CompiledGrammar::new(&amp;grammar_text, Some(grammar_file_path.to_string_lossy().as_ref()))?;
        Ok(Outputs::CompiledGrammar(compiled_grammar))
      }
      Tasks::Parse { compiled_grammar_task, program_file_path, rule_name } =&gt; {
        let Ok(Outputs::CompiledGrammar(compiled_grammar)) = context.require_task(compiled_grammar_task.as_ref()) else {
          // Return `None` if compiling grammar failed. Don't propagate the error, otherwise the error would be
          // duplicated for all `Parse` tasks.
          return Ok(Outputs::Parsed(None));
        };
        let program_text = require_file_to_string(context, program_file_path)?;
        let output = compiled_grammar.parse(&amp;program_text, rule_name, Some(program_file_path.to_string_lossy().as_ref()))?;
        Ok(Outputs::Parsed(Some(output)))
      }
    }
  }
}</code></pre>
<p>The output is <code>Result&lt;Outputs, String&gt;</code>: either an <code>Outputs</code> if the task succeeds, or a <code>String</code> if not.
In <code>execute</code> we match our variant and either compile a grammar or parse, which are mostly straightforward.
In the <code>Parse</code> variant, we require the compile grammar task, but don’t propagate its errors and instead return <code>Ok(Outputs::Parsed(None))</code>.
We do this to prevent duplicate errors.
If we propagated the error, the grammar compilation error would be duplicated into every parse task.</p>
<p>Confirm the code compiles with <code>cargo build --example parser_dev</code>.
We won’t test this code as we’ll use these tasks in the <code>main</code> function next.</p>
<h2 id="parse-cli-arguments"><a class="header" href="#parse-cli-arguments">Parse CLI arguments</a></h2>
<p>We have tasks for compiling grammars and parsing files, but we need to pass file paths and a rule name into these tasks.
We will pass this data to the program via command-line arguments.
To parse command-line arguments, we will use <a href="https://docs.rs/clap/latest/clap/" title="" target="_blank">clap</a>, which is an awesome library for easily parsing command-line arguments.
Add clap as a dependency to <code>pie/Cargo.toml</code>:</p>
<div class="diff2html" id="diff2html_4"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/Cargo.toml
+++ pie/Cargo.toml
@@ -12,3 +12,4 @@
 pest = "2"
 pest_meta = "2"
 pest_vm = "2"
+clap = { version = "4", features = ["derive"] }
`;
    let target = document.getElementById('diff2html_4');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We’re using the <code>derive</code> feature of clap to automatically derive a full-featured argument parser from a struct.
Modify <code>pie/examples/parser_dev/main.rs</code>:</p>
<div class="diff2html" id="diff2html_5"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/examples/parser_dev/main.rs
+++ pie/examples/parser_dev/main.rs
@@ -1,6 +1,20 @@
+use std::path::PathBuf;
+
+use clap::Parser;
+
 pub mod parse;
 pub mod task;
 
+#[derive(Parser)]
+pub struct Args {
+  /// Path to the pest grammar file.
+  grammar_file_path: PathBuf,
+  /// Rule name (from the pest grammar file) used to parse program files.
+  rule_name: String,
+  /// Paths to program files to parse with the pest grammar.
+  program_file_paths: Vec<PathBuf>,
+}
+
 fn main() {
-
+  let args = Args::parse();
 }
`;
    let target = document.getElementById('diff2html_5');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>The <code>Args</code> struct contains exactly the data we need: the path to the grammar file, the name of the rule to start parsing with, and paths to program files to parse.
We derive an argument parser for <code>Args</code> with <code>#[derive(Parser)]</code>.
Then we parse command-line arguments in <code>main</code> with <code>Args::parse()</code>.</p>
<p>Test this program with <code>cargo run --example parser_dev -- --help</code>, which should result in usage help for the program.
Note that the names, ordering, and doc-comments of the fields are used to generate this help.
You can test out several more commands:</p>
<ul>
<li><code>cargo run --example parser_dev --</code></li>
<li><code>cargo run --example parser_dev -- foo</code></li>
<li><code>cargo run --example parser_dev -- foo bar</code></li>
<li><code>cargo run --example parser_dev -- foo bar baz qux</code></li>
</ul>
<p>Now let’s use these arguments to actually compile the grammar and parse example program files.
Modify <code>pie/examples/parser_dev/main.rs</code>:</p>
<div class="diff2html" id="diff2html_6"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/examples/parser_dev/main.rs
+++ pie/examples/parser_dev/main.rs
@@ -1,7 +1,13 @@
+use std::fmt::Write;
 use std::path::PathBuf;
 
 use clap::Parser;
 
+use pie::Pie;
+use pie::tracker::writing::WritingTracker;
+
+use crate::task::{Outputs, Tasks};
+
 pub mod parse;
 pub mod task;
 
@@ -17,4 +23,30 @@
 
 fn main() {
   let args = Args::parse();
+  compile_grammar_and_parse(args);
+}
+
+fn compile_grammar_and_parse(args: Args) {
+  let mut pie = Pie::with_tracker(WritingTracker::with_stderr());
+
+  let mut session = pie.new_session();
+  let mut errors = String::new();
+
+  let compile_grammar_task = Tasks::compile_grammar(&args.grammar_file_path);
+  if let Err(error) = session.require(&compile_grammar_task) {
+    let _ = writeln!(errors, "{}", error); // Ignore error: writing to String cannot fail.
+  }
+
+  for path in args.program_file_paths {
+    let task = Tasks::parse(&compile_grammar_task, &path, &args.rule_name);
+    match session.require(&task) {
+      Err(error) => { let _ = writeln!(errors, "{}", error); }
+      Ok(Outputs::Parsed(Some(output))) => println!("Parsing '{}' succeeded: {}", path.display(), output),
+      _ => {}
+    }
+  }
+
+  if !errors.is_empty() {
+    println!("Errors:\n{}", errors);
+  }
 }
`;
    let target = document.getElementById('diff2html_6');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>In <code>compile_grammar_and_parse</code>, we create a new <code>Pie</code> instance that writes the build log to stderr, and create a new build session.
Then, we require a compile grammar task using the <code>grammar_file_path</code> from <code>Args</code>, and write any errors to the <code>errors</code> <code>String</code>.
We then require a parse task for every path in <code>args.program_file_paths</code>, using the previously created <code>compile_grammar_task</code> and <code>args.rule_name</code>.
Successes are printed to stdout and errors are written to <code>errors</code>.
Finally, we print <code>errors</code> to stdout if there are any.</p>
<p>To test this out, we need a grammar and some test files. Create <code>grammar.pest</code>:</p>
<pre><code>num = { ASCII_DIGIT+ }

main = { SOI ~ num ~ EOI }

WHITESPACE = _{ &quot; &quot; | &quot;\t&quot; | &quot;\n&quot; | &quot;\r&quot; }
</code></pre>
<div id="admonition-pest-grammars" class="admonition admonish-info">
<div class="admonition-title">
<p>Pest Grammars</p>
<p><a class="admonition-anchor-link" href="#admonition-pest-grammars"></a></p>
</div>
<div>
<p>It’s not important for this example to understand pest grammars, but I will explain the basics of this grammar.
Feel free to learn and experiment more if you are interested.</p>
<p>This grammar parses numbers with the <code>num</code> rule.
The <code>main</code> rule ensures that there is no additional text before and after a <code>num</code> rule, using <a href="https://pest.rs/book/grammars/syntax.html#start-and-end-of-input" title="" target="_blank">
<code>SOI</code> (start of input) <code>EOI</code> (end of input)</a>, and using the <a href="https://pest.rs/book/grammars/syntax.html#sequence" title="" target="_blank">
<code>~</code> operator to sequence</a> these rules.
We set the <a href="https://pest.rs/book/grammars/syntax.html#implicit-whitespace" title="" target="_blank">
<code>WHITESPACE</code> builtin rule</a> to <code>{ &quot; &quot; | &quot;\t&quot; | &quot;\n&quot; | &quot;\r&quot; }</code> so that spaces, tabs, newlines, and carriage return characters are implicitly allowed between returns.
The <code>_</code> operator before <code>{</code> indicates that it is a <a href="https://pest.rs/book/grammars/syntax.html#silent" title="" target="_blank">silent rule</a> that does not contribute to the parse result.</p>
</div>
</div>
<p>Create <code>test_1.txt</code> with:</p>
<pre><code>42
</code></pre>
<p>And create <code>test_2.txt</code> with:</p>
<pre><code>foo
</code></pre>
<p>Run the program with <code>cargo run --example parser_dev -- grammar.pest main test_1.txt test_2.txt</code>.
This should result in a build log showing that the grammar is successfully compiled, that one file is successfully parsed, and that one file has a parse error.</p>
<p>Unfortunately, there is no incrementality between different runs of the example, because the <code>Pie</code> <code>Store</code> is not persisted.
The <code>Store</code> only exists in-memory while the program is running, and is then thrown away.
Thus, there cannot be any incrementality.
To get incrementality, we need to serialize the <code>Store</code> before the program exits, and deserialize it when the program starts.
This is possible and not actually that hard, I just never got around to explaining it in this tutorial.
See the <a href="#side-note-serialization">Side Note: Serialization</a> section at the end for info on how this can be implemented.</p>
<div id="admonition-hiding-the-build-log" class="admonition admonish-tip">
<div class="admonition-title">
<p>Hiding the Build Log</p>
<p><a class="admonition-anchor-link" href="#admonition-hiding-the-build-log"></a></p>
</div>
<div>
<p>If you are using a bash-like shell on a UNIX-like OS, you can hide the build log by redirecting stderr to <code>/dev/null</code> with: <code>cargo run --example parser_dev -- grammar.pest main test_1.txt test_2.txt 2&gt;/dev/null</code>.
Otherwise, you can hide the build log by replacing <code>WritingTracker::with_stderr()</code> with <code>NoopTracker</code>.</p>
</div>
</div>
<p>Feel free to experiment a bit with the grammar, example files, etc. before continuing.
We will develop an interactive editor next however, which will make experimentation easier!</p>
<h2 id="interactive-parser-development"><a class="header" href="#interactive-parser-development">Interactive Parser Development</a></h2>
<p>Now we’ll create an interactive version of this grammar compilation and parsing pipeline, using <a href="https://ratatui.rs/" title="" target="_blank">Ratatui</a> to create a terminal GUI.
Since we need to edit text files, we’ll use <a href="https://github.com/rhysd/tui-textarea" title="" target="_blank">tui-textarea</a>, which is a text editor widget for Ratatui.
Ratatui works with multiple <a href="https://ratatui.rs/concepts/backends/" title="" target="_blank">backends</a>, with <a href="https://crates.io/crates/crossterm" title="" target="_blank">crossterm</a> being the default backend since it is cross-platform.
Add these libraries as a dependency to <code>pie/Cargo.toml</code>:</p>
<div class="diff2html" id="diff2html_7"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/Cargo.toml
+++ pie/Cargo.toml
@@ -13,3 +13,6 @@
 pest_meta = "2"
 pest_vm = "2"
 clap = { version = "4", features = ["derive"] }
+ratatui = "0.24"
+tui-textarea = "0.4"
+crossterm = "0.27"
`;
    let target = document.getElementById('diff2html_7');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<h3 id="ratatui-scaffolding"><a class="header" href="#ratatui-scaffolding">Ratatui Scaffolding</a></h3>
<p>We will put the editor in a separate module, and start out with the basic scaffolding of a Ratatui “Hello World” application.
Add <code>editor</code> as a public module to <code>pie/examples/parser_dev/main.rs</code>:</p>
<div class="diff2html" id="diff2html_8"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/examples/parser_dev/main.rs
+++ pie/examples/parser_dev/main.rs
@@ -10,6 +10,7 @@
 
 pub mod parse;
 pub mod task;
+pub mod editor;
 
 #[derive(Parser)]
 pub struct Args {
`;
    let target = document.getElementById('diff2html_8');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Create the <code>pie/examples/parser_dev/editor.rs</code> file and add the following to it:</p>
<pre><code class="language-rust ">use std::io;

use crossterm::event::{DisableMouseCapture, EnableMouseCapture, Event, KeyCode, KeyEventKind};
use crossterm::terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen};
use ratatui::backend::{Backend, CrosstermBackend};
use ratatui::Terminal;
use ratatui::widgets::Paragraph;

use crate::Args;

/// Live parser development editor.
pub struct Editor {}

impl Editor {
  /// Create a new editor from `args`.
  pub fn new(_args: Args) -&gt; Result&lt;Self, io::Error&gt; {
    Ok(Self {})
  }

  /// Run the editor, drawing it into an alternate screen of the terminal.
  pub fn run(&amp;mut self) -&gt; Result&lt;(), io::Error&gt; {
    // Setup terminal for GUI rendering.
    enable_raw_mode()?;
    let mut backend = CrosstermBackend::new(io::stdout());
    crossterm::execute!(backend, EnterAlternateScreen, EnableMouseCapture)?;
    let mut terminal = Terminal::new(backend)?;
    terminal.clear()?;

    // Draw and process events in a loop until a quit is requested or an error occurs.
    let result = loop {
      match self.draw_and_process_event(&amp;mut terminal) {
        Ok(false) =&gt; break Ok(()), // Quit requested
        Err(e) =&gt; break Err(e), // Error
        _ =&gt; {},
      }
    };

    // First undo our changes to the terminal.
    disable_raw_mode()?;
    crossterm::execute!(terminal.backend_mut(), LeaveAlternateScreen, DisableMouseCapture)?;
    terminal.show_cursor()?;
    // Then present the result to the user.
    result
  }

  fn draw_and_process_event&lt;B: Backend&gt;(&amp;mut self, terminal: &amp;mut Terminal&lt;B&gt;) -&gt; Result&lt;bool, io::Error&gt; {
    terminal.draw(|frame| {
      frame.render_widget(Paragraph::new(&quot;Hello World! Press Esc to exit.&quot;), frame.size());
    })?;

    match crossterm::event::read()? {
      Event::Key(key) if key.kind == KeyEventKind::Release =&gt; return Ok(true), // Skip releases.
      Event::Key(key) if key.code == KeyCode::Esc =&gt; return Ok(false),
      _ =&gt; {}
    };

    Ok(true)
  }
}</code></pre>
<p>The <code>Editor</code> struct will hold the state of the editor application, which is currently empty, but we’ll add fields to it later.
Likewise, the <code>new</code> function doesn’t do a lot right now, but it is scaffolding for when we add state.
It returns a <code>Result</code> because it can fail in the future.</p>
<p>The <code>run</code> method sets up the terminal for GUI rendering, draws the GUI and processes events in a loop until stopped, and then undoes our changes to the terminal.
It is set up in such a way that undoing our changes to the terminal happens regardless if there is an error or not (although panics would still skip that code and leave the terminal in a bad state).
This is a <a href="https://ratatui.rs/tutorial/hello-world/index.html" title="" target="_blank">standard program loop for Ratatui</a>.</p>
<details id="admonition-rust-help-returning-from-loops" class="admonition admonish-tip">
<summary class="admonition-title">
<p>Rust Help: Returning From Loops</p>
<p><a class="admonition-anchor-link" href="#admonition-rust-help-returning-from-loops"></a></p>
</summary>
<div>
<p>A <a href="https://doc.rust-lang.org/book/ch03-05-control-flow.html#repeating-code-with-loop" title="" target="_blank">
<code>loop</code> indicates an infinite loop</a>.
You can <a href="https://doc.rust-lang.org/book/ch03-05-control-flow.html#returning-values-from-loops" title="" target="_blank">return a value from such loops with <code>break</code></a>.</p>
</div>
</details>
<p>The <code>draw_and_process_event</code> method first draws the GUI, currently just a hello world message, and then processes events such as key presses.
Currently, this skips key releases because we are only interested in presses, and returns <code>Ok(false)</code> if escape is pressed, causing the <code>loop</code> to be <code>break</code>ed out.</p>
<p>Now we need to go back to our command-line argument parsing and add a flag indicating that we want to start up an interactive editor.
Modify <code>pie/examples/parser_dev/main.rs</code>:</p>
<div class="diff2html" id="diff2html_9"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/examples/parser_dev/main.rs
+++ pie/examples/parser_dev/main.rs
@@ -1,4 +1,5 @@
 use std::fmt::Write;
+use std::io;
 use std::path::PathBuf;
 
 use clap::Parser;
@@ -6,6 +7,7 @@
 use pie::Pie;
 use pie::tracker::writing::WritingTracker;
 
+use crate::editor::Editor;
 use crate::task::{Outputs, Tasks};
 
 pub mod parse;
@@ -13,6 +15,15 @@
 pub mod editor;
 
 #[derive(Parser)]
+struct Cli {
+  /// Start an interactive parser development editor.
+  #[arg(short, long)]
+  edit: bool,
+  #[command(flatten)]
+  args: Args,
+}
+
+#[derive(Parser)]
 pub struct Args {
   /// Path to the pest grammar file.
   grammar_file_path: PathBuf,
@@ -22,9 +33,15 @@
   program_file_paths: Vec<PathBuf>,
 }
 
-fn main() {
-  let args = Args::parse();
-  compile_grammar_and_parse(args);
+fn main() -> Result<(), io::Error> {
+  let cli = Cli::parse();
+  if cli.edit {
+    let mut editor = Editor::new(cli.args)?;
+    editor.run()
+  } else {
+    compile_grammar_and_parse(cli.args);
+    Ok(())
+  }
 }
 
 fn compile_grammar_and_parse(args: Args) {
`;
    let target = document.getElementById('diff2html_9');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We add a new <code>Cli</code> struct with an <code>edit</code> field that is settable by a short (<code>-e</code>) or long (<code>--edit</code>) flag, and flatten <code>Args</code> into it.
Using this new <code>Cli</code> struct here keeps <code>Args</code> clean, since the existing code does not need to know about the <code>edit</code> flag.
Instead of using a flag, you could also define a <a href="https://docs.rs/clap/latest/clap/_derive/_tutorial/chapter_0/index.html" title="" target="_blank">separate command</a> for editing.</p>
<p>In <code>main</code>, we parse <code>Cli</code> instead, check whether <code>cli.edit</code> is set, and create and run the editor if it is.
Otherwise, we do a batch build.</p>
<p>Try out the code with <code>cargo run --example parser_dev -- test.pest main test_1.test test_2.test -e</code> in a terminal, which should open up a separate screen with a hello world text.
Press escape to exit out of the application.</p>
<p>If the program ever panics, your terminal will be left in a bad state.
In that case, you’ll have to reset your terminal back to a good state, or restart your terminal.</p>
<h3 id="text-editor-buffer"><a class="header" href="#text-editor-buffer">Text Editor <code>Buffer</code></a></h3>
<p>The goal of this application is to develop a grammar alongside example programs of that grammar, getting feedback whether the grammar is correct, but also getting feedback whether the example programs can be parsed with the grammar.
Therefore, we will need to draw multiple text editors along with space for feedback, and be able to swap between active editors.
This will be the responsibility of the <code>Buffer</code> struct which we will create in a separate module.
Add the <code>buffer</code> module to <code>pie/examples/parser_dev/editor.rs</code>:</p>
<div class="diff2html" id="diff2html_10"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/examples/parser_dev/editor.rs
+++ pie/examples/parser_dev/editor.rs
@@ -8,6 +8,8 @@
 
 use crate::Args;
 
+mod buffer;
+
 /// Live parser development editor.
 pub struct Editor {}
 
`;
    let target = document.getElementById('diff2html_10');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Then create the <code>pie/examples/parser_dev/editor/buffer.rs</code> file and add to it:</p>
<pre><code class="language-rust ">#![allow(dead_code)]

use std::fs::{File, read_to_string};
use std::io::{self, Write};
use std::path::PathBuf;

use crossterm::event::Event;
use ratatui::Frame;
use ratatui::layout::{Constraint, Direction, Layout, Rect};
use ratatui::style::{Color, Modifier, Style};
use ratatui::widgets::{Block, Borders, Paragraph, Wrap};
use tui_textarea::TextArea;

/// Editable text buffer for a file.
pub struct Buffer {
  path: PathBuf,
  editor: TextArea&lt;'static&gt;,
  feedback: String,
  modified: bool,
}

impl Buffer {
  /// Create a new [`Buffer`] for file at `path`.
  ///
  /// # Errors
  ///
  /// Returns an error when reading file at `path` fails.
  pub fn new(path: PathBuf) -&gt; Result&lt;Self, io::Error&gt; {
    let text = read_to_string(&amp;path)?;
    let mut editor = TextArea::from(text.lines());

    // Enable line numbers. Default style = no additional styling (inherit).
    editor.set_line_number_style(Style::default());

    Ok(Self { path, editor, feedback: String::default(), modified: false })
  }

  /// Draws this buffer with `frame` into `area`, highlighting it if it is `active`.
  pub fn draw(&amp;mut self, frame: &amp;mut Frame, area: Rect, active: bool) {
    // Determine and set styles based on whether this buffer is active. Default style = no additional styling (inherit).
    let mut cursor_line_style = Style::default();
    let mut cursor_style = Style::default();
    let mut block_style = Style::default();
    if active { // Highlight active editor.
      cursor_line_style = cursor_line_style.add_modifier(Modifier::UNDERLINED);
      cursor_style = cursor_style.add_modifier(Modifier::REVERSED);
      block_style = block_style.fg(Color::Gray);
    }
    self.editor.set_cursor_line_style(cursor_line_style);
    self.editor.set_cursor_style(cursor_style);

    // Create and set the block for the text editor, bordering it and providing a title.
    let mut block = Block::default().borders(Borders::ALL).style(block_style);
    if let Some(file_name) = self.path.file_name() { // Add file name as title.
      block = block.title(format!(&quot;{}&quot;, file_name.to_string_lossy()))
    }
    if self.modified { // Add modified to title.
      block = block.title(&quot;[modified]&quot;);
    }
    self.editor.set_block(block);

    // Split area up into a text editor (80% of available space), and feedback text (minimum of 7 lines).
    let areas = Layout::default()
      .direction(Direction::Vertical)
      .constraints(vec![Constraint::Percentage(80), Constraint::Min(7)])
      .split(area);
    // Render text editor into first area (`areas[0]`).
    frame.render_widget(self.editor.widget(), areas[0]);
    // Render feedback text into second area (`areas[1]`).
    let feedback = Paragraph::new(self.feedback.clone())
      .wrap(Wrap::default())
      .block(Block::default().style(block_style).borders(Borders::ALL - Borders::TOP));
    frame.render_widget(feedback, areas[1]);
  }

  /// Process `event`, updating whether this buffer is modified.
  pub fn process_event(&amp;mut self, event: Event) {
    self.modified |= self.editor.input(event);
  }

  /// Save this buffer to its file if it is modified. Does nothing if not modified. Sets as unmodified when successful.
  ///
  /// # Errors
  ///
  /// Returns an error if writing buffer text to the file fails.
  pub fn save_if_modified(&amp;mut self) -&gt; Result&lt;(), io::Error&gt; {
    if !self.modified {
      return Ok(());
    }
    let mut file = io::BufWriter::new(File::create(&amp;self.path)?);
    for line in self.editor.lines() {
      file.write_all(line.as_bytes())?;
      file.write_all(b&quot;\n&quot;)?;
    }
    file.flush()?;
    self.modified = false;
    Ok(())
  }

  /// Gets the file path of this buffer.
  pub fn path(&amp;self) -&gt; &amp;PathBuf { &amp;self.path }

  /// Gets the mutable feedback text of this buffer.
  pub fn feedback_mut(&amp;mut self) -&gt; &amp;mut String { &amp;mut self.feedback }
}</code></pre>
<p>A <code>Buffer</code> is a text editor for a text file at a certain <code>path</code>.
It keeps track of a text editor with <code>TextArea&lt;'static&gt;</code>, <code>feedback</code> text, and whether the text was <code>modified</code> in relation to the file.
<code>new</code> creates a <code>Buffer</code> and is fallible due to reading a file.</p>
<p>The <code>draw</code> method draws/renders the buffer (using the Ratatui <code>frame</code>) into <code>area</code>, with <code>active</code> signifying that this buffer is active and should be highlighted differently.
The first part sets the style of the editor, mainly highlighting an active editor by using <code>Color::Gray</code> as the block style.
Default styles indicate that no additional styling is done, basically inheriting the style from a parent widget (i.e., a block), or using the style from your terminal.
The second part creates a <a href="https://ratatui.rs/how-to/widgets/block.html" title="" target="_blank">block</a> that renders a border around the text editor and renders a title on the upper border.
The third part splits up the available space into space for the text editor (80%), and space for the feedback text (at least 7 lines), and renders the text editor and feedback text into those spaces.
The layout can of course be tweaked, but it works for this example.</p>
<p><code>process_event</code> lets the text editor process input events, and updates whether the text has been modified.
<code>save_if_modified</code> saves the text to file, but only if modified.
<code>path</code> gets the file path of the buffer.
<code>feedback_mut</code> returns a mutable borrow to the feedback text, enabling modification of the feedback text.</p>
<p>It is up to the user of <code>Buffer</code> to keep track of the active buffer, sending <code>active: true</code> to the <code>draw</code> method of that buffer, and calling <code>process_event</code> on the active buffer.
That’s exactly what we’re going to implement next.</p>
<h3 id="drawing-and-updating-buffers"><a class="header" href="#drawing-and-updating-buffers">Drawing and Updating <code>Buffer</code>s</a></h3>
<p>We’ll create <code>Buffers</code> in <code>Editor</code> and keep track of the active buffer.
To keep this example simple, we’ll create buffers only for the grammar file and example program files given as command-line arguments.
If you want more or less example files, you’ll have to exit the application, add those example files to the command-line arguments, and then start the application again.</p>
<p>Modify <code>pie/examples/parser_dev/editor.rs</code>:</p>
<div class="diff2html" id="diff2html_11"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/examples/parser_dev/editor.rs
+++ pie/examples/parser_dev/editor.rs
@@ -1,22 +1,38 @@
 use std::io;
 
-use crossterm::event::{DisableMouseCapture, EnableMouseCapture, Event, KeyCode, KeyEventKind};
+use crossterm::event::{DisableMouseCapture, EnableMouseCapture, Event, KeyCode, KeyEventKind, KeyModifiers};
 use crossterm::terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen};
 use ratatui::backend::{Backend, CrosstermBackend};
+use ratatui::layout::{Constraint, Direction, Layout};
 use ratatui::Terminal;
 use ratatui::widgets::Paragraph;
 
 use crate::Args;
+use crate::editor::buffer::Buffer;
 
 mod buffer;
 
 /// Live parser development editor.
-pub struct Editor {}
+pub struct Editor {
+  buffers: Vec<Buffer>,
+  active_buffer: usize,
+}
 
 impl Editor {
   /// Create a new editor from ${"`"}args${"`"}.
-  pub fn new(_args: Args) -> Result<Self, io::Error> {
-    Ok(Self {})
+  ///
+  /// # Errors
+  ///
+  /// Returns an error when creating a buffer fails.
+  pub fn new(args: Args) -> Result<Self, io::Error> {
+    let mut buffers = Vec::with_capacity(1 + args.program_file_paths.len());
+    buffers.push(Buffer::new(args.grammar_file_path)?); // First buffer is always the grammar buffer.
+    for path in args.program_file_paths {
+      buffers.push(Buffer::new(path)?); // Subsequent buffers are always example program buffers.
+    }
+
+    let editor = Self { buffers, active_buffer: 0, };
+    Ok(editor)
   }
 
   /// Run the editor, drawing it into an alternate screen of the terminal.
@@ -47,13 +63,42 @@
 
   fn draw_and_process_event<B: Backend>(&mut self, terminal: &mut Terminal<B>) -> Result<bool, io::Error> {
     terminal.draw(|frame| {
-      frame.render_widget(Paragraph::new("Hello World! Press Esc to exit."), frame.size());
+      let root_areas = Layout::default()
+        .direction(Direction::Vertical)
+        .constraints(vec![Constraint::Percentage(100), Constraint::Min(1)])
+        .split(frame.size());
+      let buffer_areas = Layout::default()
+        .direction(Direction::Horizontal)
+        .constraints(vec![Constraint::Percentage(50), Constraint::Percentage(50)])
+        .split(root_areas[0]);
+
+      // Draw grammar buffer on the left (${"`"}buffer_areas[0]${"`"}).
+      self.buffers[0].draw(frame, buffer_areas[0], self.active_buffer == 0);
+
+      // Draw example program buffers on the right (${"`"}buffer_areas[1]${"`"}).
+      let num_program_buffers = self.buffers.len() - 1;
+      // Split vertical space between example program buffers.
+      let program_buffer_areas = Layout::default()
+        .direction(Direction::Vertical)
+        .constraints(vec![Constraint::Ratio(1, num_program_buffers as u32); num_program_buffers])
+        .split(buffer_areas[1]);
+      for ((buffer, area), i) in self.buffers[1..].iter_mut().zip(program_buffer_areas.iter()).zip(1..) {
+        buffer.draw(frame, *area, self.active_buffer == i);
+      }
+
+      // Draw help line on the last line (${"`"}root_areas[1]${"`"}).
+      let help = Paragraph::new("Interactive Parser Development. Press Esc to quit, ^T to switch the active \
+                                 buffer.");
+      frame.render_widget(help, root_areas[1]);
     })?;
 
     match crossterm::event::read()? {
       Event::Key(key) if key.kind == KeyEventKind::Release => return Ok(true), // Skip releases.
       Event::Key(key) if key.code == KeyCode::Esc => return Ok(false),
-      _ => {}
+      Event::Key(key) if key.code == KeyCode::Char('t') && key.modifiers.contains(KeyModifiers::CONTROL) => {
+        self.active_buffer = (self.active_buffer + 1) % self.buffers.len();
+      }
+      event => self.buffers[self.active_buffer].process_event(event), // Otherwise: forward to current buffer.
     };
 
     Ok(true)
`;
    let target = document.getElementById('diff2html_11');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p><code>Editor</code> now has a list of <code>buffers</code> via <code>Vec&lt;Buffer&gt;</code> and keeps track of the active tracker via <code>active_buffer</code> which is an index into <code>buffers</code>.
In <code>new</code>, we create buffers based on the grammar and program file paths in <code>args</code>.
The buffers <code>Vec</code> is created in such a way that the first buffer is always the grammar buffer, with the rest being example program buffers.
The grammar buffer always exists because <code>args.grammar_file_path</code> is mandatory, but there can be 0 or more example program buffers.</p>
<p><code>draw_and_process_event</code> now splits up the available space.
First vertically: as much space as possible is reserved for buffers, with at least 1 line being reserved for a help line at the bottom.
Then horizontally: half of the horizontal space is reserved for a grammar buffer, and the other half for program buffers.
The vertical space for program buffers (<code>program_buffer_areas</code>) is further divided: evenly split between all program buffers.</p>
<p>Then, the buffers are drawn in the corresponding spaces with <code>active</code> only being <code>true</code> if we are drawing the active buffer, based on the <code>active_buffer</code> index.</p>
<p>In the event processing code, we match the Control+T shortcut and increase the <code>active_buffer</code> index.
We wrap back to 0 when the <code>active_buffer</code> index would overflow, using a modulo (%) operator, ensuring that <code>active_buffer</code> is always a correct index into the <code>buffers</code> <code>Vec</code>.
Finally, if none of the other shortcuts match, we send the event to the active buffer.</p>
<p>Try out the code again with <code>cargo run --example parser_dev -- test.pest main test_1.test test_2.test -e</code> in a terminal.
This should open up the application with a grammar buffer on the left, and two program buffers on the right.
Use Control+T to swap between buffers, and escape to exit.</p>
<h3 id="saving-buffers-and-providing-feedback"><a class="header" href="#saving-buffers-and-providing-feedback">Saving <code>Buffer</code>s and Providing Feedback</a></h3>
<p>Next up is saving the buffers, running the compile grammar and parse tasks, and show feedback from those tasks in the feedback space of buffers.
Modify <code>pie/examples/parser_dev/editor.rs</code>:</p>
<div class="diff2html" id="diff2html_12"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/examples/parser_dev/editor.rs
+++ pie/examples/parser_dev/editor.rs
@@ -1,3 +1,4 @@
+use std::fmt::Write;
 use std::io;
 
 use crossterm::event::{DisableMouseCapture, EnableMouseCapture, Event, KeyCode, KeyEventKind, KeyModifiers};
@@ -7,8 +8,11 @@
 use ratatui::Terminal;
 use ratatui::widgets::Paragraph;
 
+use pie::Pie;
+
 use crate::Args;
 use crate::editor::buffer::Buffer;
+use crate::task::{Outputs, Tasks};
 
 mod buffer;
 
@@ -16,6 +20,8 @@
 pub struct Editor {
   buffers: Vec<Buffer>,
   active_buffer: usize,
+  rule_name: String,
+  pie: Pie<Tasks, Result<Outputs, String>>,
 }
 
 impl Editor {
@@ -31,7 +37,9 @@
       buffers.push(Buffer::new(path)?); // Subsequent buffers are always example program buffers.
     }
 
-    let editor = Self { buffers, active_buffer: 0, };
+    let pie = Pie::default();
+    let mut editor = Self { buffers, active_buffer: 0, rule_name: args.rule_name, pie };
+    editor.save_and_update_buffers(false);
     Ok(editor)
   }
 
@@ -88,7 +96,7 @@
 
       // Draw help line on the last line (${"`"}root_areas[1]${"`"}).
       let help = Paragraph::new("Interactive Parser Development. Press Esc to quit, ^T to switch the active \
-                                 buffer.");
+                                 buffer, ^S to save all buffers and provide feedback.");
       frame.render_widget(help, root_areas[1]);
     })?;
 
@@ -98,9 +106,50 @@
       Event::Key(key) if key.code == KeyCode::Char('t') && key.modifiers.contains(KeyModifiers::CONTROL) => {
         self.active_buffer = (self.active_buffer + 1) % self.buffers.len();
       }
+      Event::Key(key) if key.code == KeyCode::Char('s') && key.modifiers.contains(KeyModifiers::CONTROL) => {
+        self.save_and_update_buffers(true);
+      },
       event => self.buffers[self.active_buffer].process_event(event), // Otherwise: forward to current buffer.
     };
 
     Ok(true)
   }
+
+  fn save_and_update_buffers(&mut self, save: bool) {
+    for buffer in &mut self.buffers {
+      buffer.feedback_mut().clear();
+    }
+
+    if save {
+      for buffer in &mut self.buffers {
+        if let Err(error) = buffer.save_if_modified() {
+          // Ignore error: writing to String cannot fail.
+          let _ = writeln!(buffer.feedback_mut(), "Saving file failed: {}", error);
+        }
+      }
+    }
+
+    let mut session = self.pie.new_session();
+
+    let grammar_buffer = &mut self.buffers[0];
+    let compile_grammar_task = Tasks::compile_grammar(grammar_buffer.path());
+    match session.require(&compile_grammar_task) {
+      Err(error) => {
+        let _ = writeln!(grammar_buffer.feedback_mut(), "{}", error);
+        return; // Skip parsing if compiling grammar failed.
+      }
+      _ => {}
+    }
+
+    let compile_grammar_task = Box::new(compile_grammar_task);
+    for buffer in &mut self.buffers[1..] {
+      let task = Tasks::parse(&compile_grammar_task, buffer.path(), &self.rule_name);
+      let feedback = buffer.feedback_mut();
+      match session.require(&task) {
+        Err(error) => { let _ = writeln!(feedback, "{}", error); },
+        Ok(Outputs::Parsed(Some(output))) => { let _ = writeln!(feedback, "Parsing succeeded: {}", output); },
+        _ => {}
+      }
+    }
+  }
 }
`;
    let target = document.getElementById('diff2html_12');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>The biggest addition as at the bottom: the <code>save_and_update_buffers</code> method.
This method first clears the feedback text for all buffers, and saves all buffers (if <code>save</code> is <code>true</code>).
Then we create a new PIE session and require the compile grammar task and parse tasks, similar to <code>compile_grammar_and_parse</code> in the main file.
Here we instead <code>writeln!</code> the results to the feedback text of buffers.</p>
<p>We store the <code>rule_name</code> in <code>Editor</code> as that is needed to create parse tasks, and store a <code>Pie</code> instance so that we can create new PIE sessions to require tasks.</p>
<p>When the Control+S shortcut is pressed, we call <code>save_and_update_buffers</code> with <code>save</code> set to <code>true</code>.
We also call <code>save_and_update_buffers</code> in <code>Editor::new</code> to provide feedback when the application starts out, but with <code>save</code> set to false, so we don’t immediately save all files.
Finally, we update the help line to include the Control+S shortcut.</p>
<p>Try out the code again with <code>cargo run --example parser_dev -- test.pest main test_1.test test_2.test -e</code> in a terminal.
Now you should be able to make changes to the grammar and/or example programs, press Control+S to save modified files, and get feedback on grammar compilation and parsing example programs.
If you like, you can go through the <a href="https://pest.rs/book/" title="" target="_blank">pest parser book</a> and experiment with/develop a parser.</p>
<h3 id="showing-the-build-log"><a class="header" href="#showing-the-build-log">Showing the Build Log</a></h3>
<p>We’ll add one more feature to the editor: showing the build log.
We can do this by writing the build log to an in-memory text buffer, and by drawing that text buffer.
Modify <code>pie/examples/parser_dev/editor.rs</code>:</p>
<div class="diff2html" id="diff2html_13"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/examples/parser_dev/editor.rs
+++ pie/examples/parser_dev/editor.rs
@@ -1,14 +1,17 @@
 use std::fmt::Write;
 use std::io;
+use std::io::Cursor;
 
 use crossterm::event::{DisableMouseCapture, EnableMouseCapture, Event, KeyCode, KeyEventKind, KeyModifiers};
 use crossterm::terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen};
 use ratatui::backend::{Backend, CrosstermBackend};
 use ratatui::layout::{Constraint, Direction, Layout};
 use ratatui::Terminal;
-use ratatui::widgets::Paragraph;
+use ratatui::text::Text;
+use ratatui::widgets::{Block, Borders, Paragraph};
 
 use pie::Pie;
+use pie::tracker::writing::WritingTracker;
 
 use crate::Args;
 use crate::editor::buffer::Buffer;
@@ -21,7 +24,7 @@
   buffers: Vec<Buffer>,
   active_buffer: usize,
   rule_name: String,
-  pie: Pie<Tasks, Result<Outputs, String>>,
+  pie: Pie<Tasks, Result<Outputs, String>, WritingTracker<Cursor<Vec<u8>>>>,
 }
 
 impl Editor {
@@ -37,7 +40,7 @@
       buffers.push(Buffer::new(path)?); // Subsequent buffers are always example program buffers.
     }
 
-    let pie = Pie::default();
+    let pie = Pie::with_tracker(WritingTracker::new(Cursor::new(Vec::new())));
     let mut editor = Self { buffers, active_buffer: 0, rule_name: args.rule_name, pie };
     editor.save_and_update_buffers(false);
     Ok(editor)
@@ -73,7 +76,7 @@
     terminal.draw(|frame| {
       let root_areas = Layout::default()
         .direction(Direction::Vertical)
-        .constraints(vec![Constraint::Percentage(100), Constraint::Min(1)])
+        .constraints(vec![Constraint::Percentage(70), Constraint::Percentage(30), Constraint::Min(1)])
         .split(frame.size());
       let buffer_areas = Layout::default()
         .direction(Direction::Horizontal)
@@ -94,10 +97,26 @@
         buffer.draw(frame, *area, self.active_buffer == i);
       }
 
-      // Draw help line on the last line (${"`"}root_areas[1]${"`"}).
+      { // Draw build log on the bottom (${"`"}root_areas[1]${"`"}).
+        let text = Text::raw(String::from_utf8_lossy(&self.pie.tracker().writer().get_ref()));
+
+        // Scroll down to last line, but that hides the entire build log.
+        let scroll = text.height() as u16;
+        // Scroll up the height of the build log area, making it visible. Use saturating sub to prevent overflows.
+        let scroll = scroll.saturating_sub(root_areas[1].height);
+        // Scroll down 2 lines due to the top and bottom border taking up 2 lines.
+        let scroll = scroll + 2;
+
+        let build_log = Paragraph::new(text)
+          .block(Block::default().title("Build log").borders(Borders::ALL))
+          .scroll((scroll, 0));
+        frame.render_widget(build_log, root_areas[1]);
+      };
+
+      // Draw help line on the last line (${"`"}root_areas[2]${"`"}).
       let help = Paragraph::new("Interactive Parser Development. Press Esc to quit, ^T to switch the active \
                                  buffer, ^S to save all buffers and provide feedback.");
-      frame.render_widget(help, root_areas[1]);
+      frame.render_widget(help, root_areas[2]);
     })?;
 
     match crossterm::event::read()? {
`;
    let target = document.getElementById('diff2html_13');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>In <code>new</code> we now create the <code>Pie</code> instance with a writing tracker: <code>WritingTracker::new(Cursor::new(Vec::new()))</code>.
This writing tracker writes to a <a href="https://doc.rust-lang.org/std/io/struct.Cursor.html" title="" target="_blank">
<code>Cursor</code></a>, specifically <code>Cursor&lt;Vec&lt;u8&gt;&gt;</code> for which <a href="https://doc.rust-lang.org/src/std/io/cursor.rs.html#570-591" title="" target="_blank">
<code>Write</code> is implemented</a>.
We modify the type of the <code>pie</code> field to include the tracker type to reflect this: <code>WritingTracker&lt;Cursor&lt;Vec&lt;u8&gt;&gt;&gt;</code>.
Build logs will then be written to the <code>Vec&lt;u8&gt;</code> inside the <code>Cursor</code>.</p>
<p>To draw the build log in between the buffers and help line, we first modify the layout split into <code>root_areas</code>: buffers now take up 70% of vertical space, and add a new constraint for the build log which takes 30% of vertical space.</p>
<p>We access the in-memory buffer via <code>&amp;self.pie.tracker().writer().get_ref()</code>, convert this to a string via <a href="https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf8_lossy" title="" target="_blank">
<code>String::from_utf8_lossy</code></a>, and convert that to <a href="https://docs.rs/ratatui/latest/ratatui/text/struct.Text.html" title="" target="_blank">Ratatui <code>Text</code></a> which can be passed to <a href="https://docs.rs/ratatui/latest/ratatui/widgets/struct.Paragraph.html#method.new" title="" target="_blank">
<code>Paragraph::new</code></a> and also gives us line information for scrolling the build log.
The scroll calculation is explained in the comments.
We then draw the build log as a <code>Paragraph</code>.</p>
<p>Finally, we update the area for the help line from <code>root_areas[1]</code> to <code>root_areas[2]</code>, as adding the layout constraint shifted the index up.</p>
<p>Try out the code again with <code>cargo run --example parser_dev -- test.pest main test_1.test test_2.test -e</code> in a terminal.
Pressing Control+S causes tasks to be required, which is shown in the build log.
Try modifying a single file to see what tasks PIE executes, or what the effect of an error in the grammar has.</p>
<p>And with that, we’re done with the interactive parser development example 🎉🎉🎉!</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In this example, we developed tasks for compiling a grammar and parsing files with that grammar, and then used those tasks to implement both a batch build, and an interactive parser development environment.</p>
<p>In the introduction, we <a href="../0_intro/index.html#motivation">motivated</a> programmatic incremental build systems with the key properties of: programmatic, incremental, correct, automatic, and multipurpose.
Did these properties help with the implementation of this example application?</p>
<ul>
<li>Programmatic: due to the build script – that is: the compile grammar and parse tasks – being written in the same programming language as the application, it was extremely simple to integrate. We also didn’t have to learn a separate language, we could just apply our knowledge of Rust!</li>
<li>Incremental: PIE incrementalized the build for us, so we didn’t have to implement incrementality.
<ul>
<li>The batch build is unfortunately not incremental due to not having implemented serialization in this tutorial, but this is not a fundamental limitation. See <a href="#side-note-serialization">Side Note: Serialization</a> for info on how to solve this.</li>
</ul>
</li>
<li>Correct: PIE ensures the build is correct, so we don’t have to worry about glitches or inconsistent data.
<ul>
<li>For a real application, we should write tests to increase the confidence that our build is correct, because PIE checks for correctness at runtime.</li>
</ul>
</li>
<li>Automatic: we didn’t manually implement incrementality, but only specified the dependencies: from compile grammar/parse task to a file, and from parse tasks to compile grammar tasks. This saves development time that would be spent on incrementalization and making sure that it is correct. For larger applications, this can end up saving a lot of development time.</li>
<li>Multipurpose: we reused the same tasks for both a batch build and for use in an interactive environment, without any modifications. Again, this saves development time.</li>
</ul>
<p>So yes, I think programmatic incremental build systems, and in particular PIE, help a lot when developing these kind of applications.
In larger applications, the benefits can be even larger, due to saving more development time.</p>
<p>You should of course decide for yourself whether PIE really helped with implementing this example.
Every problem is different, and requires separate considerations as to what tools are the best for solving that particular problem.</p>
<p>This is currently the end of the guided programming tutorial.
In the appendix chapters, we discuss PIE implementations and publications, related work, and future work.</p>
<details id="admonition-download-source-code" class="admonition admonish-example">
<summary class="admonition-title">
<p>Download source code</p>
<p><a class="admonition-anchor-link" href="#admonition-download-source-code"></a></p>
</summary>
<div>
<p>You can <a href="../../gen/4_example/source.zip">download the source files up to this point</a>.</p>
</div>
</details>
<h2 id="side-note-serialization"><a class="header" href="#side-note-serialization">Side Note: Serialization</a></h2>
<p>To get incrementality between different runs (i.e., processes) of the program, we need to serialize the <code>Store</code> before the program exits, and deserialize the <code>Store</code> when the program starts.</p>
<p>The de-facto standard (and awesome) serialization library in Rust in <a href="https://serde.rs/" title="" target="_blank">serde</a>.
See the <a href="https://github.com/Gohla/pie/blob/pre_type_refactor/pie/" title="" target="_blank">PIE in Rust repository at the <code>pre_type_refactor</code> tag</a> for a version of PIE with serde serialization.
For example, the <a href="https://github.com/Gohla/pie/blob/pre_type_refactor/pie/src/store.rs#L14-L17" title="" target="_blank">
<code>Store</code></a> struct has annotations for deriving <code>serde::Deserialize</code> and <code>serde::Serialize</code>.
These attributes are somewhat convoluted due to serialization being optional, and due to the <code>H</code> generic type parameter which should not be included into serialization bounds.</p>
<p>You should derive <code>serde::Deserialize</code> and <code>serde::Serialize</code> for all required types in the PIE library, but also all tasks, and all task outputs.
The <code>pie_graph</code> library support serialization when the <code>serde</code> feature is enabled, which is enabled by default.
Then, see <a href="https://github.com/Gohla/pie/blob/pre_type_refactor/pie/tests/serde.rs" title="" target="_blank">this serialization integration test</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../3_min_sound/7_cycle/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../a_appendix/1_pie.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../3_min_sound/7_cycle/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../a_appendix/1_pie.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src=".././diff2html-ui-base.min.js"></script>


    </div>
    </body>
</html>
