<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Introduction - Build your own Programmatic Incremental Build System</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././diff2html.min.css">
        <link rel="stylesheet" href=".././mdbook-admonish.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../0_intro/index.html" class="active"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../0_intro/1_setup/index.html"><strong aria-hidden="true">1.1.</strong> Setup</a></li></ol></li><li class="chapter-item expanded "><a href="../1_programmability/index.html"><strong aria-hidden="true">2.</strong> Programmability</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../1_programmability/1_api/index.html"><strong aria-hidden="true">2.1.</strong> Programmable Build System API</a></li><li class="chapter-item expanded "><a href="../1_programmability/2_non_incremental/index.html"><strong aria-hidden="true">2.2.</strong> Non-Incremental Context</a></li></ol></li><li class="chapter-item expanded "><a href="../2_incrementality/index.html"><strong aria-hidden="true">3.</strong> Incrementality</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../2_incrementality/1_require_file/index.html"><strong aria-hidden="true">3.1.</strong> Requiring Files</a></li><li class="chapter-item expanded "><a href="../2_incrementality/2_stamp/index.html"><strong aria-hidden="true">3.2.</strong> Stamps</a></li><li class="chapter-item expanded "><a href="../2_incrementality/3_dependency/index.html"><strong aria-hidden="true">3.3.</strong> Dynamic Dependencies</a></li><li class="chapter-item expanded "><a href="../2_incrementality/4_store/index.html"><strong aria-hidden="true">3.4.</strong> Dependency Graph Store</a></li><li class="chapter-item expanded "><a href="../2_incrementality/5_context/index.html"><strong aria-hidden="true">3.5.</strong> Incremental Top-Down Context</a></li><li class="chapter-item expanded "><a href="../2_incrementality/6_example/index.html"><strong aria-hidden="true">3.6.</strong> Incrementality Example</a></li></ol></li><li class="chapter-item expanded "><a href="../3_min_sound/index.html"><strong aria-hidden="true">4.</strong> Testing Incrementality & Correctness</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../3_min_sound/1_session/index.html"><strong aria-hidden="true">4.1.</strong> Incrementality with Sessions</a></li><li class="chapter-item expanded "><a href="../3_min_sound/2_tracker/index.html"><strong aria-hidden="true">4.2.</strong> Tracking Build Events</a></li><li class="chapter-item expanded "><a href="../3_min_sound/3_test/index.html"><strong aria-hidden="true">4.3.</strong> Integration Testing</a></li><li class="chapter-item expanded "><a href="../3_min_sound/4_fix_task_dep/index.html"><strong aria-hidden="true">4.4.</strong> Fix Superfluous Task Dependency</a></li><li class="chapter-item expanded "><a href="../3_min_sound/5_overlap/index.html"><strong aria-hidden="true">4.5.</strong> Prevent Overlapping File Writes</a></li><li class="chapter-item expanded "><a href="../3_min_sound/6_hidden_dep/index.html"><strong aria-hidden="true">4.6.</strong> Prevent Hidden Dependencies</a></li><li class="chapter-item expanded "><a href="../3_min_sound/7_cycle/index.html"><strong aria-hidden="true">4.7.</strong> Prevent Cycles</a></li></ol></li><li class="chapter-item expanded "><a href="../4_example/index.html"><strong aria-hidden="true">5.</strong> Project: Interactive Parser Development</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../4_example/1_grammar/index.html"><strong aria-hidden="true">5.1.</strong> Compiling Grammars and Parsing</a></li><li class="chapter-item expanded "><a href="../4_example/2_task/index.html"><strong aria-hidden="true">5.2.</strong> Task Implementation</a></li><li class="chapter-item expanded "><a href="../4_example/3_cli/index.html"><strong aria-hidden="true">5.3.</strong> CLI for Incremental Batch Builds</a></li><li class="chapter-item expanded "><a href="../4_example/4_interactive/index.html"><strong aria-hidden="true">5.4.</strong> Interactive Parser Development</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="../a_appendix/1_pie.html"><strong aria-hidden="true">6.</strong> PIE Implementations & Publications</a></li><li class="chapter-item expanded "><a href="../a_appendix/2_related_work.html"><strong aria-hidden="true">7.</strong> Related Work</a></li><li class="chapter-item expanded "><a href="../a_appendix/3_future_work.html"><strong aria-hidden="true">8.</strong> Future Work</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
<!-- CHANGE: removed all but light and ayu theme, and renamed ayu to dark -->                          
<!--                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>-->
<!--                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>-->
<!--                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>-->
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Dark</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Build your own Programmatic Incremental Build System</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Gohla/pie/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Gohla/pie/edit/master/tutorial/src/0_intro/index.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="build-your-own-programmatic-incremental-build-system"><a class="header" href="#build-your-own-programmatic-incremental-build-system">Build your own Programmatic Incremental Build System</a></h1>
<p>This is a programming tutorial where you will build your own <em>programmatic incremental build system</em>, which is a mix between an incremental build system and an incremental computation system.
Programmatic incremental build systems enable programmers to write expressive build scripts and interactive programs in a regular programming language, with the system taking care of correct incrementality once and for all, freeing programmers from having to manually implement complicated and error-prone incrementality every time.</p>
<p>The primary goal of this tutorial is to provide understanding of programmatic incremental build systems through implementation and experimentation.</p>
<p>In this programming tutorial you will write <a href="https://www.rust-lang.org/" title="" target="_blank">Rust</a> code, but you <em>don’t</em> need to be a Rust expert to follow it.
A secondary goal of this tutorial is to teach more about Rust through implementation and experimentation, given that you already have some programming experience (in another language) and are willing to learn. 
Therefore, all Rust code is available, and I try to explain and link to the relevant Rust book chapters as much as possible.</p>
<p>This is of course not a full tutorial or book on Rust.
For that, I can recommend the excellent <a href="https://doc.rust-lang.org/book/" title="" target="_blank">The Rust Programming Language</a> book.
However, if you like to learn through examples and experimentation, or already know Rust basics and want to practice, this might be a fun programming tutorial for you!</p>
<p>We will first motivate programmatic incremental build systems in more detail.</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>A programmatic incremental build system is a mix between an incremental build system and an incremental computation system, with the following key properties:</p>
<ul>
<li><em>Programmatic</em>: Build scripts are regular programs written in a programming language, where parts of the program implement an API from the build system. This enables programmers to write incremental builds scripts and interactive programs with the full expressiveness of the programming language.</li>
<li><em>Incremental</em>: Builds are truly incremental – only the parts of a build that are affected by changes are executed.</li>
<li><em>Correct</em>: Builds are fully correct – all parts of the build that are affected by changes are executed. Builds are free of glitches: only up-to-date (consistent) data is observed.</li>
<li><em>Automatic</em>: The system takes care of incrementality and correctness. Programmers <em>do not</em> have to manually implement incrementality. Instead, they only have to explicitly <em>declare dependencies</em>.</li>
</ul>
<p>To show the benefits of a build system with these key properties, below is a simplified version of the build script for compiling a formal grammar and parsing text with that compiled grammar, which is the build script you will implement in the <a href="../4_example/index.html">final project chapter</a>.
This simplified version removes details that are not important for understanding programmatic incremental build systems at this moment.</p>
<div id="admonition-info" class="admonition admonish-info">
<div class="admonition-title">
<p>Info</p>
<p><a class="admonition-anchor-link" href="#admonition-info"></a></p>
</div>
<div>
<p>Don’t worry if you do not (fully) understand this code, the tutorial will guide you more with programming and understanding this kind of code.
This example is primarily here to motivate programmatic incremental build systems, as it is hard to do so without it.</p>
</div>
</div>
<pre><code class="language-rust">pub enum ParseTasks {
  CompileGrammar { grammar_file: PathBuf },
  Parse { compile_grammar_task: Box&lt;ParseTasks&gt;, text_file: PathBuf, rule_name: String }
}

pub enum Outputs {
  CompiledGrammar(CompiledGrammar),
  Parsed(String)
}

impl Task for ParseTasks {
  fn execute&lt;C: Context&gt;(&amp;self, context: &amp;mut C) -&gt; Result&lt;Outputs, Error&gt; {
    match self {
      ParseTasks::CompileGrammar { grammar_file } =&gt; {
        let grammar_text = context.require_file(grammar_file)?;
        let compiled_grammar = CompiledGrammar::new(&amp;grammar_text)?;
        Ok(Outputs::CompiledGrammar(compiled_grammar))
      }
      ParseTasks::Parse { compile_grammar_task, text_file, rule_name } =&gt; {
        let compiled_grammar = context.require_task(compile_grammar_task)?;
        let text = context.require_file(text_file)?;
        let output = compiled_grammar.parse(&amp;text, rule_name)?;
        Ok(Outputs::Parsed(output))
      }
    }
  }
}

fn main() {
  let compile_grammar_task = Box::new(ParseTasks::CompileGrammar {
    grammar_file: PathBuf::from(&quot;grammar.pest&quot;)
  });
  let parse_1_task = ParseTasks::Parse {
    compile_grammar_task: compile_grammar_task.clone(),
    text_file: PathBuf::from(&quot;test_1.txt&quot;),
    rule_name: &quot;main&quot;
  };
  let parse_2_task = ParseTasks::Parse {
    compile_grammar_task: compile_grammar_task.clone(),
    text_file: PathBuf::from(&quot;test_2.txt&quot;),
    rule_name: &quot;main&quot;
  };
  
  let mut context = IncrementalBuildContext::default();
  let output_1 = context.require_task(&amp;parse_1_task).unwrap();
  println(&quot;{output_1:?}&quot;);
  let output_2 = context.require_task(&amp;parse_2_task).unwrap();
  println(&quot;{output_2:?}&quot;);
}</code></pre>
<p>This is in essence just a normal (pure) Rust program: it has enums, a trait implementation for one of those enums, and a <code>main</code> function.
However, this program is also a build script because <code>ParseTasks</code> implements the <code>Task</code> trait, which is the core trait defining the unit of computation in a programmatic incremental build system.
Because <code>ParseTasks</code> is an enum, there are two kinds of tasks: a <code>CompileGrammar</code> task that compiles a grammar, and a <code>Parse</code> task that parses a text file using the compiled grammar.</p>
<h5 id="tasks"><a class="header" href="#tasks">Tasks</a></h5>
<p>A <em>task</em> is kind of like a closure: a function along with its inputs that can be executed.
For example, <code>CompileGrammar</code> carries <code>grammar_file_path</code> which is the file path of the grammar that it will compile.
When we <code>execute</code> a <code>CompileGrammar</code> task, it reads the text of the grammar from the file, compiles that text into a grammar, and returns a compiled grammar.</p>
<p>Tasks differ from closures however, in that tasks are <em>incremental</em>.</p>
<h5 id="incremental-file-dependencies"><a class="header" href="#incremental-file-dependencies">Incremental File Dependencies</a></h5>
<p>We want the <code>CompileGrammar</code> task to be incremental, such that this task is only re-executed when the contents of the <code>grammar_file</code> file changes.
Therefore, <code>execute</code> has a <code>context</code> parameter which is an <em>incremental build context</em> that tasks use to tell the build system about dependencies.</p>
<p>For example, <code>CompileGrammar</code> tells the build system that it <em>requires</em> the <code>grammar_file</code> file with <code>context.require_file(grammar_file)</code>, creating a <em>file read dependency</em> to that file.
It is then the responsibility of the incremental build system to only execute this task if the file contents have changed.</p>
<h5 id="dynamic-dependencies"><a class="header" href="#dynamic-dependencies">Dynamic Dependencies</a></h5>
<p>Note that this file dependency is created <em>while the task is executing</em>!
We call these <em>dynamic dependencies</em>, as opposed to static dependencies.
Dynamic dependencies enable the <em>programmatic</em> part of programmatic incremental build systems, because dependencies are made while your program is running, and can thus depend on values computed earlier in your program.</p>
<h5 id="incremental-task-dependencies"><a class="header" href="#incremental-task-dependencies">Incremental Task Dependencies</a></h5>
<p>Dynamic dependencies are also created <em>between tasks</em>.
For example, <code>Parse</code> carries <code>compile_grammar_task</code> which is an instance of the <code>CompileGrammar</code> task to compile a grammar.
When we <code>execute</code> a <code>Parse</code> task, it tells the build system that it depends on the compile grammar task with <code>context.require_task(compile_grammar_task)</code>.</p>
<p>This also asks the build system to return the most up-to-date (consistent) output of that task.
It is then the responsibility of the incremental build system to <em>check</em> whether the task is <em>consistent</em>, and to <em>re-execute</em> it only if it is <em>inconsistent</em>.
In essence, the build system will take these steps:</p>
<ul>
<li>If <code>compile_grammar_task</code> was never executed before, the build system executes it, caches the compiled grammar, and returns the compiled grammar.</li>
<li>Otherwise, to check if the compile grammar task is consistent, we need to check its dependencies: the file dependency to <code>grammar_file</code>.
<ul>
<li>If the contents of the <code>grammar_file</code> file has changed, the task is inconsistent and the build system re-executes it, caches the new compiled grammar, and returns it.</li>
<li>Otherwise, the task is consistent and the build system simply returns the cached compiled grammar.</li>
</ul>
</li>
</ul>
<p>The <code>Parse</code> task then has access to the <code>compiled_grammar</code>, reads the text file to parse with <code>require_file</code>, and finally parses the <code>text</code> with <code>compiled_grammar.parse</code>.</p>
<h5 id="using-tasks"><a class="header" href="#using-tasks">Using Tasks</a></h5>
<p>Because this is just a regular Rust program, we can use the tasks in the same program with a <code>main</code> function.
The <code>main</code> function creates instances of these tasks, creates an <code>IncrementalBuildContext</code>, and asks the build system to return the up-to-date outputs for two tasks with <code>context.require_task</code>.</p>
<p>This <code>main</code> function is performing an incremental batch build.
However, you can also use these same tasks to build an <em>interactive application</em>.
That is too much code to discuss here in this introduction, but the <a href="../4_example/index.html">final project chapter</a> shows a video of an interactive application that you can build using these tasks.</p>
<h5 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h5>
<p>This is the essence of programmatic incremental build systems.
In this tutorial, we will define the <code>Task</code> trait and implement the <code>IncrementalBuildContext</code> over the course of several chapters.</p>
<p>However, before we start doing that, I want to first zoom back out and discuss the benefits (and drawbacks) of programmatic incremental build systems.
If you already feel motivated enough, you can <a href="#pie-a-programmatic-incremental-build-system-in-rust">skip to here</a>.</p>
<h3 id="benefits"><a class="header" href="#benefits">Benefits</a></h3>
<p>The primary motivation for programmatic incremental build systems is that you can <em>program</em> your incremental builds and interactive applications in a regular programming language, instead of having to write it in a separate (declarative) build script language, and this has several benefits:</p>
<ul>
<li>You can re-use your knowledge of the programming language, instead of having to learn a new build script language.</li>
<li>You can use tools of the programming language, such as the compiler that provides (good) error messages, an IDE that helps you read and write code, a debugger for understanding the program, unit and integration testing for improving code reliability, benchmarking for improving performance, etc.</li>
<li>You can modularize your build script using facilities of the programming language, enabling you to reuse your build script as a library or to use modules created by others in your build script. You can also use regular modules of the programming language and integrate them into build scripts, and vice versa.</li>
</ul>
<p>The other important benefit is that incrementality and correctness are taken care of by the build system.
Therefore, you don’t have to manually implement incrementality in a correct way, which is complicated and error-prone to implement.</p>
<p>You do have to specify the exact dependencies of tasks to files and other tasks, as seen in the example, but this is easier than implementing incrementality.
Due to the dependencies being dynamic, you can use regular programming language constructs like calling a function to figure out what file to depend on, <code>if</code> to create conditional dependencies, <code>while</code> to create multiple dependencies, and so forth.</p>
<p>Exactly specifying the dependencies in this way has another important benefit: the dynamic dependencies of a task <em>perfectly describe when the task should be re-executed</em>, enabling the build system to be fully incremental and correct.
This is in contrast to build system with static dependencies – dependencies that cannot use runtime values, typically using literal file names or patterns – where dependencies often have to be over-approximated (not fully incremental) or under-approximated (not correct) due to not being able to exactly specify dependencies.</p>
<p>Some build systems use <em>multiple stages</em> to emulate a limited form of dynamic dependencies.
For example, dynamic dependencies in <a href="https://www.gnu.org/software/make/" title="" target="_blank">Make</a> requires staging: first dynamically generate new makefiles with correct dependencies, and then recursively execute them.
<a href="https://gradle.org/" title="" target="_blank">Gradle</a> has a two-staged build process: first configure the task graph, then incrementally execute it, but no new dependencies nor tasks can be created during execution.
This is an improvement over static dependencies, but requires you to think about what to do in each stage, requires maintenance of each stage, and limits what you can do in each stage.</p>
<p>A final benefit of dynamic dependencies is that they do away with staging because there is only a single stage: the execution of your build script, and you can create dynamic dependencies in this single stage.
This increases expressiveness, makes build scripts easier to read and write, and reduces maintenance overhead. </p>
<h3 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h3>
<p>Of course, programmatic incremental build systems also have some drawbacks.
These drawbacks become more clear during the tutorial, but I want to list them here to be up-front about it:</p>
<ul>
<li>The build system is more complicated, but hopefully this tutorial can help mitigate some of that by understanding the key ideas through implementation and experimentation.</li>
<li>Some correctness properties are checked while building. Therefore, you need to test your builds to try to catch these issues before they reach users. However, I think that testing builds is something you should do regardless of the build system, to be more confident about the correctness of your build.</li>
<li>More tracking is required at runtime compared to non-programmatic build systems. However, in our experience, the overhead is not excessive unless you try to do very fine-grained incrementalization. For fine-grained incrementalization, <a href="https://en.wikipedia.org/wiki/Incremental_computing" title="" target="_blank">incremental computing</a> approaches are more well suited.</li>
</ul>
<h2 id="pie-a-programmatic-incremental-build-system-in-rust"><a class="header" href="#pie-a-programmatic-incremental-build-system-in-rust">PIE: a Programmatic Incremental Build System in Rust</a></h2>
<p>We have developed <a href="https://github.com/Gohla/pie" title="" target="_blank">PIE, a Rust library</a> implementing a programmatic incremental build system adhering to the key properties listed above.
It is still under development, and has not been published to crates.io yet, but it is already usable 
If you are interested in experimenting with a programmatic incremental build system, do check it out!</p>
<p>In this tutorial we will implement a subset of PIE.
We simplify the internals in order to minimize distractions as much as possible, but still go over all the key ideas and concepts that make programmatic incremental build systems tick.</p>
<p>However, the <em>idea</em> of programmatic incremental build systems is not limited to PIE or the Rust language.
You can implement a programmatic incremental build systems in any general-purpose programming language, or adapt the idea to better fit your preferences and/or requirements.
In fact, we first implemented <a href="https://github.com/metaborg/pie" title="" target="_blank">PIE in Java</a>, with <a href="https://github.com/Gohla/pie" title="" target="_blank">PIE in Rust</a> being the second iteration, mostly simplifying internals to make it easier to explain.</p>
<p>For a more thorough discussion on PIE, see the <a href="../a_appendix/1_pie.html">PIE Implementations &amp; Publications appendix chapter</a>, and the <a href="../a_appendix/2_related_work.html">Related Work appendix chapter</a>.</p>
<h2 id="feedback--contributing"><a class="header" href="#feedback--contributing">Feedback &amp; Contributing</a></h2>
<p>This tutorial is open source, hosted at <a href="https://github.com/Gohla/pibs" target="_blank">https://github.com/Gohla/pibs</a>.
If you find an error in the code or text of this tutorial, or want to report other kinds of problems, you can report it on the <a href="https://github.com/Gohla/pibs/issues" title="" target="_blank">issue tracker</a>.
Small fixes can be sent as a pull request by pressing the edit button in the top-right corner.</p>
<p>Let’s continue with the tutorial.
The next section covers installing Rust and setting up a fresh Rust project.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->

                            <a rel="next" href="../0_intro/1_setup/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

                    <a rel="next" href="../0_intro/1_setup/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src=".././diff2html-ui-base.min.js"></script>


    </div>
    </body>
</html>
